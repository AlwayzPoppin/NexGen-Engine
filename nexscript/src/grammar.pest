// NexScript Grammar - PEG Definition
// A game-focused scripting language for NexGen Engine

// Whitespace and comments
WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\r\n" | "\n" | "\r" }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }

// Entry point
program = { SOI ~ NEWLINE* ~ (statement ~ NEWLINE*)* ~ EOI }

// Statements
statement = _{
    entity_def |
    fn_def |
    signal_def |
    state_machine_def |
    variable_decl |
    assignment |
    if_stmt |
    while_stmt |
    for_stmt |
    return_stmt |
    emit_stmt |
    expression
}

// Entity definition
entity_def = {
    "entity" ~ identifier ~ ":" ~ NEWLINE ~
    INDENT ~ entity_body ~ DEDENT
}

entity_body = { (entity_member ~ NEWLINE*)* }

entity_member = _{
    component_def |
    fn_def |
    signal_def |
    variable_decl
}

// Component definition
component_def = {
    "component" ~ identifier ~ (":" ~ NEWLINE ~ INDENT ~ component_body ~ DEDENT)?
}

component_body = { (component_field ~ NEWLINE*)* }

component_field = { identifier ~ "=" ~ expression }

// Function definition
fn_def = {
    async_keyword? ~ "fn" ~ identifier ~ "(" ~ param_list? ~ ")" ~ return_type? ~ ":" ~ NEWLINE ~
    INDENT ~ block ~ DEDENT
}

async_keyword = { "async" }

param_list = { param ~ ("," ~ param)* }
param = { identifier ~ ":" ~ type_expr }

return_type = { "->" ~ type_expr }

// Signal definition
signal_def = {
    "signal" ~ identifier ~ "(" ~ param_list? ~ ")"
}

// State machine definition
state_machine_def = {
    "state_machine" ~ identifier ~ ":" ~ NEWLINE ~
    INDENT ~ state_machine_body ~ DEDENT
}

state_machine_body = {
    ("initial" ~ "=" ~ identifier ~ NEWLINE)? ~
    (state_def ~ NEWLINE*)*
}

state_def = {
    "state" ~ identifier ~ ":" ~ NEWLINE ~
    INDENT ~ block ~ DEDENT
}

// Variable declaration
variable_decl = {
    "let" ~ identifier ~ (":" ~ type_expr)? ~ "=" ~ expression
}

// Assignment
assignment = {
    lvalue ~ assign_op ~ expression
}

lvalue = { identifier ~ ("." ~ identifier)* }

assign_op = { "=" | "+=" | "-=" | "*=" | "/=" }

// Control flow
if_stmt = {
    "if" ~ expression ~ ":" ~ NEWLINE ~
    INDENT ~ block ~ DEDENT ~
    elif_clause* ~
    else_clause?
}

elif_clause = {
    "elif" ~ expression ~ ":" ~ NEWLINE ~
    INDENT ~ block ~ DEDENT
}

else_clause = {
    "else" ~ ":" ~ NEWLINE ~
    INDENT ~ block ~ DEDENT
}

while_stmt = {
    "while" ~ expression ~ ":" ~ NEWLINE ~
    INDENT ~ block ~ DEDENT
}

for_stmt = {
    "for" ~ identifier ~ "in" ~ expression ~ ":" ~ NEWLINE ~
    INDENT ~ block ~ DEDENT
}

return_stmt = { "return" ~ expression? }

emit_stmt = { "emit" ~ identifier ~ "(" ~ arg_list? ~ ")" }

// Block (list of statements)
block = { (statement ~ NEWLINE*)* }

// Expressions
expression = { or_expr }

or_expr = { and_expr ~ ("or" ~ and_expr)* }
and_expr = { not_expr ~ ("and" ~ not_expr)* }
not_expr = { "not"? ~ comparison }
comparison = { add_expr ~ (comp_op ~ add_expr)* }
add_expr = { mul_expr ~ (add_op ~ mul_expr)* }
mul_expr = { unary_expr ~ (mul_op ~ unary_expr)* }
unary_expr = { unary_op? ~ postfix_expr }
postfix_expr = { primary ~ postfix* }

postfix = _{
    call |
    index |
    member_access
}

call = { "(" ~ arg_list? ~ ")" }
index = { "[" ~ expression ~ "]" }
member_access = { "." ~ identifier }

primary = _{
    float_literal |
    int_literal |
    string_literal |
    bool_literal |
    vec2_literal |
    vec3_literal |
    list_literal |
    map_literal |
    "(" ~ expression ~ ")" |
    identifier
}

// Operators
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
add_op = { "+" | "-" }
mul_op = { "*" | "/" | "%" }
unary_op = { "-" | "not" }

// Argument list
arg_list = { arg ~ ("," ~ arg)* }
arg = { (identifier ~ ":")? ~ expression }

// Types
type_expr = {
    generic_type |
    simple_type
}

simple_type = { identifier }
generic_type = { identifier ~ "<" ~ type_list ~ ">" }
type_list = { type_expr ~ ("," ~ type_expr)* }

// Literals
int_literal = @{ ASCII_DIGIT+ }
float_literal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
bool_literal = { "true" | "false" }

vec2_literal = { "Vec2" ~ "(" ~ expression ~ "," ~ expression ~ ")" }
vec3_literal = { "Vec3" ~ "(" ~ expression ~ "," ~ expression ~ "," ~ expression ~ ")" }

list_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
map_literal = { "{" ~ (map_entry ~ ("," ~ map_entry)*)? ~ "}" }
map_entry = { (string_literal | identifier) ~ ":" ~ expression }

// Identifiers
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Indentation (handled specially by preprocessor)
INDENT = { "{{INDENT}}" }
DEDENT = { "{{DEDENT}}" }
